=1
#include <cassert>
#include <cstdio>
#include <initializer_list>
#include <utility>
#include "parser.inc"

constexpr size_t log2_r(size_t n, size_t a)
{
	return n == 1 ? a : log2_r(n>>1, a+1);
}
constexpr size_t log2(size_t n)
{
	return log2_r(n, 0);
}

template <size_t N>
class bitset {
	static const size_t unit = sizeof(long)*8;
	static const size_t lunit = log2(unit);
	static const size_t n = (N+unit-1)/unit;
	unsigned long data[n];
public:
	bitset(): data() {}
	bitset(std::initializer_list<int> l): data()
	{
		for (auto index: l)
			set(index);
	}
	bool get(int index) const
	{
		return data[index>>lunit] & (1<<(index&(unit-1)));
	}
	void set(int index)
	{
		data[index>>lunit] |= (1<<(index&(unit-1)));
	}
	void clear(int index)
	{
		data[index>>lunit] &= ~(1<<(index&(unit-1)));
	}
	bitset<N> operator|(const bitset<N> &that) const
	{
		bitset<N> result(*this);
		for (size_t i=0; i<n; i++)
			result.data[i] |= that.data[i];
		return result;
	}
};
=2
static bool expect(int s, set &&t, set &&f)
{
	if (sym == s) {
		getsym();
		return true;
	}
	fprintf(stderr, "%d:%d: syntax error at ‘%.*s’\n",
		lineno, colno, toklen, tokstart);
	for (;;) {
		if (t.get(sym)) return true;
		if (f.get(sym)) return false;
		fprintf(stderr, "%d:%d: [skipping ‘%.*s’]\n",
			lineno, colno, toklen, tokstart);
		getsym();
	}
}
