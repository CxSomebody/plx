<program> ::= <block>.
<block> ::= [<const_part>][<var_part>]{<proc_def>|<func_def>}<comp_stmt>
<const_part> ::= T_CONST <const_def> {,<const_def>};
<const_def> ::= IDENT = <constant>
<constant> ::= [+|-]INT | CHAR
<var_part> ::= T_VAR <var_decl>; {<var_decl>;}
<var_decl> ::= IDENT{,IDENT} : <type>
<type> ::= <basic_type> | T_ARRAY'['INT']' T_OF <basic_type>
<basic_type> ::= T_INTEGER | T_CHAR
<proc_def> ::= <proc_header><block>; {<proc_header><block>;}
<func_def> ::= <func_header><block>; {<func_header><block>;}
<proc_header> ::= T_PROCEDURE IDENT[<param_list>];
<func_header> ::= T_FUNCTION IDENT[<param_list>]: <basic_type>;
<param_list> ::= '('<param_group>{; <param_group>}')'
<param_group> ::= [T_VAR] IDENT {, IDENT} : <basic_type> 
<stmt> ::= <call_stmt>|<assign_stmt>|<cond_stmt>|<do_while_stmt>|<comp_stmt>|<read_stmt>|<write_stmt>|<for_stmt>|<empty>
<assign_stmt> ::= IDENT['['<expr>']'] BECOMES <expr>
<expr> ::= [+|-]<term>{<add_op><term>}
<term> ::= <factor>{<mul_op><factor>}
<factor> ::= IDENT [ '['<expr>']' | <arg_list> ] | INT | '('<expr>')'
<arg_list> ::= '(' <expr> {, <expr>} ')'
<add_op> ::= +|-
<mul_op> ::= *|/
<cond> ::= <expr><rel_op><expr>
<rel_op> ::= <|GE|>|LE|=|NE
<cond_stmt> ::= T_IF <cond> T_THEN <stmt> [ T_ELSE <stmt> ]
<do_while_stmt> ::= T_DO <stmt> T_WHILE <cond>
<for_stmt> ::= T_FOR IDENT BECOMES <expr> (T_DOWNTO|T_TO) <expr> T_DO <stmt>
<call_stmt> ::= IDENT::is_proc [<arg_list>]
<comp_stmt> ::= T_BEGIN <stmt> {; <stmt>} T_END
<read_stmt> ::= T_READ '('IDENT{,IDENT}')'
<write_stmt> ::= T_WRITE '(' ( STRING [, <expr>] | <expr> ) ')'
<WEAK> ::= ';'
