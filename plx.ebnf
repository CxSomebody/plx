<program> ::= <block>.
<block> ::= @push_symtab [<const_part>][<var_part>]{<proc_def>|<func_def>}<comp_stmt> @pop_symtab
<const_part> ::= T_CONST <const_def> {,<const_def>};
<const_def> ::= IDENT↑name = <constant>↑val @def_const↓(name,val)
<constant> ↑ <int> v ::= <opt_sign>↑s INT↑i @{v=s?-i:i;} | CHAR↑c @{v=c;}
<opt_sign> ↑ <bool> s ::= @{s=0;} [+|-@{s=1;}]
<var_part> ::= T_VAR <var_decl>; {<var_decl>;}
<var_decl> ::= <id_list>↑ids : <type>↑ty @def_vars↓(ids,ty)
<id_list> ↑ <vector<string>> v ::= IDENT↑id1 @{v.push_back(id1);} {, IDENT↑id2 @{v.push_back(id2);} }
<type> ↑ <Type*> ty ::= <basic_type>↑ty | T_ARRAY'['INT↑n']' T_OF <basic_type>↑elty @array_type↓(elty,n)↑ty
<basic_type> ↑ <Type*> ty ::= T_INTEGER @int_type↑ty | T_CHAR @char_type↑ty
<proc_def> ::= <proc_header>↑(name,params) @def_proc↓(name,params) <block>;
<func_def> ::= <func_header>↑(name,params,rty) @def_func↓(name,params,rty) <block>;
<proc_header> ↑ (<string> name, <vector<NameTypePair>> params) ::= T_PROCEDURE IDENT↑name [<param_list>↑params];
<func_header> ↑ (<string> name, <vector<NameTypePair>> params, <Type*> rty) ::= T_FUNCTION IDENT↑name [<param_list>↑params]: <basic_type>↑rty ;
<param_list> ↑ <vector<NameTypePair>> params ::= '(' <ntpair_group>↓params {; <ntpair_group>↓params} ')'
<ntpair_group> ↓ <vector<NameTypePair>> ntpairs ::= [T_VAR] <id_list>↑names : <basic_type>↑ty @push_ntpair_group↓(ntpairs,names,ty)
<stmt> ::= <call_stmt>|<assign_stmt>|<cond_stmt>|<do_while_stmt>|<comp_stmt>|<read_stmt>|<write_stmt>|<for_stmt>|<empty>
<assign_stmt> ::= IDENT['['<expr>↑index']'] BECOMES <expr>↑val
<expr> ↑ <Expr*> e ::= <opt_sign>↑s <term>↑e {<add_op>↑op <term>↑e2 @binary_expr↓(op,e,e2)↑e}
<term> ↑ <Expr*> e ::= <factor>↑e {<mul_op>↑op <factor>↑e2 @binary_expr↓(op,e,e2)↑e}
<factor> ↑ <Expr*> e ::= IDENT↑name @ident_expr↓name↑e [ '['<expr>↑index']' @index_expr↓(e,index)↑e | <arg_list> ] | INT↑i @lit_expr↓i↑e | '('<expr>↑e')'
<arg_list> ::= '(' <expr>↑e1 {, <expr>↑e2} ')'
<add_op> ↑ <Expr::Op> op ::= +@{op = Expr::ADD;}|-@{op = Expr::SUB;}
<mul_op> ↑ <Expr::Op> op ::= *@{op = Expr::MUL;}|/@{op = Expr::DIV;}
<cond> ::= <expr>↑e1 <rel_op> <expr>↑e2
<rel_op> ::= '<'|GE|'>'|LE|=|NE
<cond_stmt> ::= T_IF <cond> T_THEN <stmt> [ T_ELSE <stmt> ]
<do_while_stmt> ::= T_DO <stmt> T_WHILE <cond>
<for_stmt> ::= T_FOR IDENT BECOMES <expr>↑e1 (T_DOWNTO|T_TO) <expr>↑e2 T_DO <stmt>
<call_stmt> ::= IDENT?is_proc [<arg_list>]
<comp_stmt> ::= T_BEGIN <stmt> {; <stmt>} T_END
<read_stmt> ::= T_READ '('IDENT{,IDENT}')'
<write_stmt> ::= T_WRITE '(' ( STRING [, <expr>↑e] | <expr>↑e ) ')'
IDENT ↑ <string> s
INT ↑ <int> i
CHAR ↑ <int> i
@int_type ↑ <Type*>
@char_type ↑ <Type*>
@array_type ↑ <Type*>
@binary_expr ↑ <Expr*>
@index_expr ↑ <Expr*>
@ident_expr ↑ <Expr*>
@lit_expr ↑ <Expr*>
