lexer出错如何处理？如引号不匹配
报错，跳至下一行

weak terminal的处理

对于{}型anon-nterm

<empty> 对应的 return true 之前
判断sym是否属于T集合

if (sym == $weak0) {
	getsym();
recover0:
	...
}
if (sym == $weak1) {
	getsym();
recover1:
	...
}
if (!t.get(sym)) {
	if (set{...}.get(sym)) {
		error_missing($weak0);
		goto recover0;
	}
	if (set{...}.get(sym)) {
		error_missing($weak1);
		goto recover1;
	}
}
return true;

nterm为{}型，且choice首符号为weak-term
规则太复杂

常见语法错误：
行尾缺分号

<assign_stmt>和<call_stmt>的冲突问题
semantic predicates?
弊病：不利于日后实现 procedures/functions as first-class values
考虑到已经有 func := ... 这样的规则，不做也罢
可以像MATLAB那样用'@'把function变成value
想做LALR(1)
弊病：不便于实现 mid-rule action

RD可以处理产生式右部首符号为动作符号的情况

<call_stmt> ::= IDENT [<arg_list>]
带有 semantic predicate 的记法：
<call_stmt> ::= IDENT::isproc [<arg_list>]
表示isproc是个函数 svtype(IDENT) -> bool, conceptually...
实现大略如下：
bool isproc() {
	return lookup(tokval.str)->type == PROCEDURE;
}

<const_def> :: ()(<SymbolTable> st)
<非终结符> :: (<类型> 输出（综合）属性名)(<类型> 输入（继承）属性名)
输入输出属性均可有多个
输出属性数目为1时，可省略括号，以增强可读性
内部属性（右部符号输出的非接口属性）需要声明局部变量
无名动作符号不接受参数列表，因为无意义
用户提供具名动作过程定义
<out_type> action(in_type...)
动作符号至多有一个输出属性

TODO: 参数检查
TODO: union tokval
